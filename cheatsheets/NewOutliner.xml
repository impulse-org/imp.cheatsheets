<?xml version="1.0" encoding="UTF-8"?>
<cheatsheet title="Creating a text Outliner for a new IMP IDE">
<intro>
<description>
The goal of this step is to create a service that provides an outline view of documents in your language.
As is typical, a IMP wizard that creates a skeleton class that contains the generic structure of the outliner,
and this must be tailored to create an outliner for the specific language being defined.
<br/><br/>

This step must be performed after the grammar and parsing service have been defined,
but it can be performed in any order with respect to the generation of other IDE services.
<br/><br/>

</description>
</intro>




<item title="Create an outliner">
<action pluginId="org.eclipse.imp.cheatsheets"
        class="org.eclipse.imp.cheatsheets.actions.NewOutlinerAction"/>
<description>
To run the New Outliner wizard, invoke<br/><br/>
"File" -> "New" -> "IDE Language Support" -> "Editor Services" -> "Outliner"
<br/><br/>
In the wizard, as usual, assure that the names of your project and language are correct and, if desired,
edit the default values provided for the implementation package and class.  Hit "Finish" when done.
<br/><br/>

The Outliner wizard creates a safari.outliner package containing an Outliner class (and an Images class).
The wizard also adds an outliner extension to the plugin.xml file for the language project and opens the Outliner class in an editor.
<br/><br/>

The generated Outliner class extends org.eclipse.uide.defaults.DefaultOutliner.
The principle method in DefaultOutliner is createOutlinePresentation(), which retrieves the current AST
(from an IParseController) and then visits the AST, populating the outline tree with various TreeItems
corresponding to AST nodes of interest.
The visiting is done by an instance of the OutlineVisitor class, which is a member of the generated Outliner class
and extends the AbstractVisitor class.
<br/><br/>

The AbstractVisitor class contains default visit(..) and endVisit(..) methods for all node types in the AST.
These methods will traverse the AST but otherwise have no effect.
(The AbstractVisitor class is usually located in the “parser.Ast” package or—-depending on parser-generator options—-it may be
contained as a member class within the generated parser class.)
<br/><br/>

To add a program entity to the outline, in the OutlineVisitor class simply override the default visit(..)
method corresponding to that type of AST node.  Most overriding methods will call createSubItem(..) with an appropriate label.
The visit(..) method should return true (or false) depending on whether the children of the node should be visited (or not).
When an item label is created it is pushed onto a stack.
Thus, whenever a default visit method is overridden to create an item label, the corresponding endVisit(..) method should also be
overridden in order to pop the item label from the stack.
Note that items that are inherently childless do not need to be pushed onto the stack, and if these items are not pushed
onto the stack then it is unnecessary to override endVisit(..) for them.
<br/><br/>

Some example visit(..) methods for the simple expression language are shown in the generated Outliner.OutlineVisitor class
(which may prevent the generated file from compiling).  These must be adapted for the specific language being defined.
<br/><br/>

It is necessary to have one visit(..) method that calls createTopItem(..) to create a root for the outline.
(It is also necessary to have a corresponding endVisit(..) method.)
This may be for some high-level node type (such as “program”) or it may be given a label that does not correspond	
to a specific node type.
<br/><br/><br/>

The generated Outliner class is somewhat dependent on JikesPG:<br/><br/>
    * The TokenColorer class implements a Parsersym interface that is one of the standard,
    language-specific interfaces generated by JikesPG<br/><br/>
    * One of its central methods (to set the outline tree) makes use of IToken, which is defined in lpg.runtime<br/><br/>
    * The createOutlinePresentation(..) method takes an instance of an IParseController which,
    although it is defined by IMP, has a default implementation that makes use of several types generated by JikesPG<br/><br/>
As noted elsewhere, it is possible to implement these various interfaces without using JikesPG
(although it is the intention of IMP to relieve the developer of this work by automating the implementation using JikesPG).
<br/><br/>

</description>
</item>


</cheatsheet>

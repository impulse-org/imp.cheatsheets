<?xml version="1.0" encoding="UTF-8"?>
<cheatsheet title="Creating a Grammar, Lexer, and Parser for a new SAFARI IDE">
<intro>
<description>
The goal of this step is to create a grammar for the language and a lexer and parser based on this grammar.
Many of the language-specific SAFARI IDE services depend on these.
Thus, this step must be performed after the language descriptor has been created but before any
language-specific IDE services are generated.
<br/><br/>

SAFARI provides support for defining the grammar and the lexer and parser using the LPG parser generator
(formerly and still occasionally known as "JikesPG"), although SAFARI can accommodate other approaches.
This cheat sheet focuses on the use of LPG, but a few comments on other approaches are included below.
<br/><br/>

SAFARI support in this area is provided through a wizard that generates skeleton files for lexer and
parser grammars, which then need to be completed by the IDE developer with specific language details.
The JikesPG builder can then automatically generate lexer, parser, and related classes
(including AST node types) based on the grammar definitions.
<br/><br/>

</description>
</intro>


<item title="Create a grammar and parser specification">
<action pluginId="org.eclipse.imp.cheatsheets"
        class="org.eclipse.imp.cheatsheets.actions.NewParserAction"/>
<description>

To run the wizard to generate the grammar skeletons, invoke
"File" -> "New" -> "IDE Language Support" -> "Parser Services" -> "JikesPG Grammar and Parser for SAFARI".
<br/><br/>
 In the wizard:<br/><br/>
    * Be sure that the proper names are entered into the project and language fields.
    (These may be filled in automatically or you may have to set them manually.)
    As these values are entered, reasonable default values will be automatically entered into other fields.<br/><br/>
    
    * If you wish, edit the "class" field to specify a non-default fully-qualified name for the parse controller
    that will be generated by the wizard. This class is used to give access to the token stream, AST, and so on,
    to the various higher-level language services
    (Note:  A parse controller is necessary, so this field should be given a usable class name.)<br/><br/>
    
    * For the "templates" field most users will want to use the default setting of "UIDE"
    (which indicates to JikesPG where it can find the grammar file templates)<br/><br/>
    
    * For the "options", check or uncheck these according to your own needs:<br/>
          o "Language has keywords" should be checked or not according to whether your language has keywords;
          this will affect the generation of a keyword lexer<br/>
          o "Language requires backtracking" should be checked or not according to whether your language requires
          a backtracking parser; this will affect the ability of the generated pareser to backtrack<br/>
          o "JikesPG auto-generated AST classes" should be checked or not according to whether you want
          JikesPG to automatically generate AST classes for your language.  (This can be a big convenience.)<br/><br/>
    * Hit "Finish" when done editing.
<br/><br/><br/>

Finishing the wizard has the effect of adding a parser extension to the plugin.xml file in your language project.
The wizard also creates one or two packages in the source folder of the language project:<br/><br/>
The “parser” package (typically called something like “languagename.safari.parser”) is always generated. 
This package is initially populated with two class files and three grammar-files.
The grammar files include one “.g” file that contains the main parser grammar and two “.gi” (“grammar include”) files,
one for a keyword lexer and one for a general lexer.
The classs are the ParseController, which is the class through which parse-related services and data are accessed
by other SAFARI services, and the ASTNodeLocator, with which the parser (or other clients) can find nodes in an AST.
When the grammar files are instantiated, that should trigger the execution of the JikesPG builder, which is provided with
SAFARI, and that builder should generate a number of additional classes that provide particular parts of the
lexer and pareser implementations on which the ParseController and ASTNodeLocator depend.
(Also see "Notes about compilation", below.)
<br/><br/>

The “AST” package (typically called something like “languagename.safari.parser.Ast”), if generated, will contain an interface
for the each nonterminal in the grammar and a class for each production in the grammar.
It will also contain useful classes for representing AST nodes and AST visitors.
This package is generated by default when the the option "JikesPG auto-generated AST classes" is checked. 
<br/><br/>
(It is also possible, by configuring the JikesPG options differently, to have the AST-related types generated as members
within the parser class.  This is controlled by the "automatic_ast" option within the ".g" file.
With the option given as "automatic_ast=toplevel" a separate AST package is generated.
If this option is changed to "automatic_ast=nested"--or just "automatic_ast"--then the AST-related classes are generated
as members of the parser class.  For this document we assume that the AST is represented in its own package.)
<br/><br/>

Additionally upon finishing the wizard, the JikesPG grammar file for your language will open in the editor,
and the structure of the file should appear in the "Outline" view.
<br/><br/>

The grammar files contain some generally useful elements (including directives to JikesPG regarding generation)
and some simple instructions for completing the files.
The files also include some example entries for a simple expression language.
You will need to edit these file as appropriate for your language.
A quickstart guide to JikesPG, as well as links to additional documentation on JikesPG, is found here.
As noted there, the JikesPG grammar files make ample provision for the inclusion of custom code in a generated parser.
The grammar files may be edited in any order.  However, for purposes of generation, the general lexer depends on the keyword
lexer and the parser depends on the general lexer.
<br/><br/>

Your language project should be configured to include the JikesPG Grammar File Builder.
This should happen automatically when you run the parsing-service wizard.
If for some reason your language project is not configured to include the JikesPG builder,
then you can enable the builder by selecting the "Enable JikesPG Builder" in the context menu for the project.
If for some reason you want to run JikesPG manually (which shouldn't usually be neecessary), you can find information about that here.
<br/><br/><br/>

Notes about compilation:<br/><br/>

The generated parser classes will have a compilation dependency on the lpg.runtime plugin, which is provided as part of the SAFARI release.
When the Jikes PG grammar and parser wizard is run, the wizard adds a plugin dependency on lpg.runtime to your language project.
However, although the dependency on lpg should then appear in the plugin dependency list for your project, it may not actually be recognized.
As a result, the ParseController may not compile properly.  To cause the new dependency to be recognized, it seems that the plugin.xml file,
or the dependencies within it, must be manipulated somehow.
For instance, if the plugin.xml file is open, you can go to the dependencies tab, select the lpg dependency, and move it up or down in the
dependencies list, afterwards saving the file.
That should cause the dependency to be recognized and trigger a recompilation of the project, which should succeed.
<br/><br/>

If your grammar defines a type with a name that duplicates one of the Java type names (such as “Number”),
then you will need to disambiguate references to this type in the parser (which can be done by explicitly importing
the corresponding AST node types for your language).  The Java compiler should make any problem like this evident to you.
<br/><br/><br/>

Other approaches<br/><br/>

If you have your own parser:  Since the goal of this step is to produce a lexer and parser, if you already have a lexer and parser
that meet SAFARI requirements then these may be used directly.
The "Hand-written Parser" wizard allows you to select an existing parser and creates a corresponding parser extension in the plugin.xml file.
To work within SAFARI, any "hand written" or non-JikesPG-generated parser should, at a minimum, implement the ILexer, IParser,
and IParseController interfaces in the org.eclipse.uide.parser package in the org.eclipse.uide.runtime project.
This will entail providing implementations for several additional types defined by SAFARI or JikesPG.
(Some of these, unfortunately, are currently defined by concrete types, although we expect to provide interfaces for these in the future.)
Thus, at this time we recommend the use of JikesPG to generate parsers for use in SAFARI.
NOTE:  If you have a parser that was generated by JikesPG but outside of SAFARI, it should be relatively straightforward to adapt it to SAFARI.
<br/><br/>

If you have your own grammar:  If JikesPG is to be used to generate the lexer and parser, but you already have grammars for the language
to be parsed, then these may be substituted into, or in place of, the SAFARI-generated templates.
Of course, the resulting grammar files must be compatible with JikesPG.
<br/><br/>

</description>
</item>

</cheatsheet>

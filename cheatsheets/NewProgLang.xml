<?xml version="1.0" encoding="UTF-8"?>
<cheatsheet title="Creating a New SAFARI Programming Language using JikesPG">
<intro>
<description>
This cheat sheet describes the basic process for creating a new SAFARI-supported
programming language where the language parser is generated using JikesPG.
The various steps entail the generation of extensions for capabilities such
as text editing, outlining, token coloring, source folding, and project building.
These extensions are represented by classes that reqiure some straightforward
specialization by the user, depending on the particular language.
<br/>

Note:  The new language must be executed in an existing plugin project.
For now, the name of the project must match the name of the language to be
created.  Thus you may want to create a new, language-specific plugin
project before continuing through this cheat sheet.
Also note that each SAFARI language has to be defined in a distinct project.
</description>
</intro>

<item title="Create a language description">
<action pluginId="com.ibm.watson.safari.cheatsheets"
        class="com.ibm.watson.safari.cheatsheets.actions.NewLanguageAction"/>
<description>
Invoke "File" -&gt; "New" -&gt; "IDE Language Support" -&gt; "Programming Language".<br/>

Enter (or browse to) the project in which you want to create your language.
Fill out the "language" field with a unique name.
Each language service implementation is associated with the language for which it is
intended by means of this unique name.
(Remember that for now the language and project names must be the same.)<br/>

Enter any user-readable text you like in the "description" field.<br/>

Enter a comma-separated list of file-name extensions in the "extensions" field
(do not include dots).
A file whose name has any of these extensions will be assumed to contain source code in the
new programming language, and the language services defined for this language will
become available to the developer while editing such files.<br/>

Hit "Finish" when done editing the various fields.<br/>

A SAFARI language description extension will be created using the above information.<br/>
</description>
</item>



<item title="Create a grammar and lexer specification">
<action pluginId="com.ibm.watson.safari.cheatsheets"
        class="com.ibm.watson.safari.cheatsheets.actions.NewParserAction"/>
<description>
Invoke "File" -&gt; "New" -&gt; "IDE Language Support" -&gt; "Parser Services" -&gt;
"JikesPG Grammar and Parser for UIDE".<br/>

Be sure that the proper names are entered into the project and language fields.
As these values are entered, reasonable default values will be entered into other fields.
<br/>

If you wish, edit the "id" field to specify a non-default extension ID for the
parsing service.<br/>

If you wish, edit the "name" field to specify a non-default name for the
parsing service. This parameter is not presently used, but is intended to be
the user-visible name for the parser.<br/>

If you wish, edit the "class" field to specify a non-default fully-qualified
name for the parse controller. This class is used to give access to the token
stream, AST, and so on, to the various higher-level language services.<br/>

Hit "Finish" when done editing.  The JikesPG grammar file for your language will be
open in the editor, and the structure of the file should appear in the "Outline"
view.  The grammar file will contain some generally useful elements and some example
entries for a simple expression language.  You will need to edit this file
as apprpriate for your language.  (To acquire JikesPG--otherwise known as lpg--see
http://sourceforge.net/projects/lpg.)<br/>

Note:  The generated parser classes will depend on lpg to compile, so
the lpg.jar file should be added to your language project's build path.<br/>

</description>
</item>


<item title="Create a token colorer">
<action pluginId="com.ibm.watson.safari.cheatsheets"
        class="com.ibm.watson.safari.cheatsheets.actions.NewTokenColorerAction"/>
<description>
Invoke "File" -&gt; "New" -&gt; "IDE Language Support" -&gt; "Editor Services" -&gt;
"Token Colorer".<br/>

As before, assure that the names of your project and language have been entered
into the appropriate fields.
If desired, edit the remaining fields. Hit "Finish" when done.<br/>

You should see that the editor opens up the token colorer implementation.
The token colorer class has two important methods: the constructor, in which
a set of TextAttribute's are created (which are later used to specify the
text presentation for the various token kinds), and the getColoring() method,
which returns the TextAttribute to be used for the given token.<br/>

As you can see, getColoring() calls IToken.getKind() to determine the token
kind (represented by an integer), and uses that to compute the correct text
attributes. The set of valid token kinds is defined by the lexical analyzer;
they are typically located in the generated "Parsersym" interface (in the parser package),
and generally start with a prefix like "TK_".
</description>
</item>

<item title="Create an outliner">
<action pluginId="com.ibm.watson.safari.cheatsheets"
        class="com.ibm.watson.safari.cheatsheets.actions.NewOutlinerAction"/>
<description>
Invoke "File" -&gt; "New" -&gt; "IDE Language Support" -&gt; "Editor Services" -&gt;
"Outliner".<br/>

As before, enter the names of your project and language into the corresponding fields
and, if desired, edit the remaining fields. Hit "Finish" when done.<br/>

The outliner implementation should open in the editor.
The Outliner class only has one important method: the createOutlinePresentation(),
which typically retrieves the current AST from the IParseController and visits
it to populate the outline tree with various TreeItems.
Some example visit methods for the simple expression language are shown in the
generated class.<br/>

To add a program entity to the outline, simply override the visit method corresponding
to that type of AST node and have the overriding mehtod call createSubItem() with an appropriate label.
(The AbstractVisitor class contains default visit methods for all node types in
the AST.  This class may be located in a separate AST package or--depending on
parser-generator options--contained as a member class within the generated parser.)
</description>
</item>


<item title="Create a builder">
<action pluginId="com.ibm.watson.safari.cheatsheets"
        class="com.ibm.watson.safari.cheatsheets.actions.NewBuilderAction"/>
<description>
Invoke "File" -&gt; "New" -&gt; "IDE Language Support" -&gt; "Core Services" -&gt;
"Incremental Builder".<br/>

As before, assure that the names of your project and language are entered in
the proper fields and, if desired, edit the remaining fields. Hit "Finish" when done.<br/>

Although it is not necessary to define a nature to which your builder will be
associated, this is a fairly common practice.  If the values for "hasNature" and
"isConfigurable" are left blank then they are treated as if false.<br/>

Although the parameter "name" and "value" fields are required here, they need to be
given meaningful values only if your builder will make use of external information
(which is not necessary for many builders).<br/>

The IncrementalProjectBuilder implementation should open up in the editor.<br/>

The skeleton builder overrides or implements several methods (defined in its abstract
parent class SAFARIBuilderBase):<br/>
 - getErrorMarker()<br/>
 - getInfoMarker()<br/>
 - getWarningMarker()<br/>
 - getPlugin()<br/>
 - isSourceFile()<br/>
 - isOutputFolder()<br/>
 - compile()<br/>

Many of these will do reasonable things "out of the box". You will undoubtedly need to
edit compile() to actually call out to your compiler in some fashion, retrieve the
diagnostic messages and turn them into markers in the "Problems" view. If your
compiler runs in an external process, or uses java.io to create output files, you'll
also need to call IResource.refresh() on the folder that contains all the generated
output files (assuming that it is somewhere in your workspace).<br/>

Note:  You may need to define an implementation of IMessageHandler, so that the builder
can provide a message handler to the compiler, which the compiler can then use to call
back to the builder to report error messages.

</description>
</item>

<item title="To use your new language ...">
<description>
To use your new language and SAFARI IDE in a development project, you will need to
add a corresponding builder entry to the project's ".project" file.
If you have defined a nature for your language, you may also want to add a nature
entry to the project's ".project" file.
</description>
</item>


</cheatsheet>
